using BuildingBlocks;

using LanguageExt;
using LanguageExt.Common;

using PaymentGateway.Abstraction;
using PaymentGateway.Abstraction.Models;

namespace PaymentGateway.Services;

public class CardValidator(ICurrencyProvider currencyProvider)
{
    public Validation<Error, PaymentProcessorRequest> ValidateRequest(PaymentProcessorRequest request)
    {
        return ValidateCardNumber(request.CardNumber)
            .Bind(_ => ValidateAmount(request.Amount))
            .Bind(_ => ValidateCurrency(request.Currency))
            .Bind(_ => ValidateExpirationDate(request.ExpiryMonth, request.ExpiryYear))
            .Bind(_ => ValidateCvv(request.Cvv))
            .Map(_ => request); // if all is successful just return the original object
    }

    public Validation<Error, int> ValidateAmount(int amount)            // this was not in the requirements, but it made sense. Other option would be to use unsigned int.
    {
        return amount > 0
            ? Success(amount)
            : Fail<int>($"Amount must be greater than zero. Was: [{amount}]");
    }

    public Validation<Error, int> ValidateCvv(int cvv)
    {
        return cvv is > 99 and <= 9999
            ? Success(cvv)
            : Fail<int>($"CVV must be between 3 and 4 characters long. Was: [{cvv}]");

    }

    public Validation<Error, (int, int)> ValidateExpirationDate(int month, int year)
    {
        // Ensure Month and year validations are taken into account first
        return ValidateExpirationMonth(month)
            .Bind(_ => ValidateExpirationYear(year))
            .Bind(_ =>
            {
                var lastDayOfMonth = new DateTime(year, month, 1).AddMonths(1).AddDays(-1);
                return lastDayOfMonth >= SystemDateTime.Now.Date
                    ? Success((month, year))
                    : Fail<(int, int)>("Card expired");
            })
            .Map(_ => (month, year));
    }

    public Validation<Error, int> ValidateExpirationMonth(int month)
    {
        return month is > 0 and <= 12
            ? Success(month)
            : Fail<int>($"Expiry month must be between 1 and 12, was [{month}]");
    }

    public Validation<Error, int> ValidateExpirationYear(int year)
    {
        return year >= SystemDateTime.Now.Year
            ? Success(year)
            : Fail<int>($"Year must be in the future, provided [{year}]");
    }

    public Validation<Error, string> ValidateCurrency(string? currency)
    {
        if (string.IsNullOrWhiteSpace(currency) || currency.Length != 3)
            return Fail<string>("Currency must be three characters long.");

        return !currencyProvider.GetSupportedCurrencies().Contains(currency.ToUpper())          // the supported currencies provider could handle currency-specific validations here.
            ? Fail<string>($"Unsupported currency [{currency}]")
            : Success(currency);
    }

    public Validation<Error, long> ValidateCardNumber(long cardNumber)
    {
        if (cardNumber < 0)
            return Fail<long>($"Negative card number provided: [{cardNumber}]");

        var card = cardNumber.ToString();
        if (card.Length is < 14 or > 19)
            return Fail<long>($"Credit card number must be between 14 and 19 characters long. Was: [{card.Length}] characters long");

        return IsValidLuhn(cardNumber)
            ? Success(cardNumber)
            : Fail<long>($"Luhn checksum check failed for card [{cardNumber}]");            // I'm not sure about this one - here we're returning an incorrect card number to the client
    }

    private static bool IsValidLuhn(long cardNumber)
    {
        // this was generated by Copilot - I'm not sure of the validity.
        //  I needed extra check of the card, since not all 19-digit numbers can fit into long.
        int sum = 0;
        bool doubleDigit = false;

        while (cardNumber > 0)
        {
            int digit = (int)(cardNumber % 10); // Extract the last digit

            if (doubleDigit)
            {
                digit *= 2;
                if (digit > 9) digit -= 9; // Subtract 9 if the result is two digits
            }

            sum += digit;
            doubleDigit = !doubleDigit; // Toggle the flag

            cardNumber /= 10; // Remove the last digit
        }

        // Valid if the sum is a multiple of 10
        return sum % 10 == 0;
    }

    private static Validation<Error, T> Fail<T>(string message) 
        => Validation<Error, T>.Fail(Error.New(message));

    private static Validation<Error, T> Success<T>(T input)
        => Validation<Error, T>.Success(input);
}