using System.Reflection.Metadata.Ecma335;

using BuildingBlocks;

using LanguageExt;
using LanguageExt.Common;

using PaymentGateway.Api.Models.Requests;

using NotImplementedException = System.NotImplementedException;

namespace PaymentGateway.Api.Services
{
    public class CardValidator(IList<string> supportedCurrencies)
    {
        public Validation<Error, PostPaymentRequest> ValidateRequest(PostPaymentRequest request)
        {
            return ValidateCardNumber(request.CardNumber)
                .Bind(_ => ValidateCurrency(request.Currency))
                .Bind(_ => ValidateExpirationDate(request.ExpiryMonth, request.ExpiryYear))
                .Bind(_ => ValidateCvv(request.Cvv))
                .Map(_ => request); // if all is successful just return the original object
        }

        public Validation<Error, int> ValidateCvv(int cvv)
        {
            return cvv is > 99 and <= 9999
                ? Success(cvv)
                : Fail<int>("CVV must be between 3 and 4 characters long");

        }

        public Validation<Error, (int, int)> ValidateExpirationDate(int month, int year)
        {
            return ValidateExpirationMonth(month)
                .Bind(_ => ValidateExpirationYear(year))
                .Bind(_ =>
                {
                    var lastDayOfMonth = new DateTime(year, month, 1).AddMonths(1).AddDays(-1);
                    return lastDayOfMonth >= SystemDateTime.Now.Date
                        ? Success((month, year))
                        : Fail<(int, int)>("Expiry date must be in the future");
                })
                .Map(_ => (month, year));
        }

        public Validation<Error, int> ValidateExpirationMonth(int month)
        {
            return month is > 0 and <= 12
                ? Success(month)
                : Fail<int>($"Expiry month must be between 1 and 12, was [{month}]");
        }

        public Validation<Error, int> ValidateExpirationYear(int year)
        {
            return year >= SystemDateTime.Now.Year
                ? Success(year)
                : Fail<int>($"Year must be in the future, provided [{year}]");
        }

        public Validation<Error, string> ValidateCurrency(string? currency)
        {
            if (string.IsNullOrWhiteSpace(currency) || currency.Length != 3)
                return Fail<string>("Currency must be three characters long.");

            return !supportedCurrencies.Contains(currency.ToUpper()) 
                ? Fail<string>($"Unsupported currency {currency}")
                : Success(currency);
        }

        public Validation<Error, long> ValidateCardNumber(long cardNumber)
        {
            if (cardNumber < 0)
                return Fail<long>($"Negative card number provided: [{cardNumber}]");

            var card = cardNumber.ToString();
            if (card.Length is < 14 or > 19)
                return Fail<long>($"Incorrect card length of [{card.Length}]");

            return IsValidLuhn(cardNumber)
                ? Success(cardNumber)
                : Fail<long>($"Luhn checksum check failed for card [{card.Length}]");
        }

        private static bool IsValidLuhn(long cardNumber)
        {
            // this was generated by Copilot - I'm not sure of the validity.
            //  I needed extra check of the card, since not all 19-digit numbers can fit into long.
            int sum = 0;
            bool doubleDigit = false;

            while (cardNumber > 0)
            {
                int digit = (int)(cardNumber % 10); // Extract the last digit

                if (doubleDigit)
                {
                    digit *= 2;
                    if (digit > 9) digit -= 9; // Subtract 9 if the result is two digits
                }

                sum += digit;
                doubleDigit = !doubleDigit; // Toggle the flag

                cardNumber /= 10; // Remove the last digit
            }

            // Valid if the sum is a multiple of 10
            return sum % 10 == 0;
        }

        private static Validation<Error, T> Fail<T>(string message) 
            => Validation<Error, T>.Fail(Error.New(message));

        private static Validation<Error, T> Success<T>(T input)
            => Validation<Error, T>.Success(input);

    }
}
